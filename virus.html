<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>VIRUS</title>
<style>
  :root{
    /* spawn image size range */
    --spawn-min: 18vmin;
    --spawn-max: 36vmin;
  }
  html,body{ height:100%; margin:0; overflow:hidden; }
  body{
    background:#000 url('pbg.png') center/cover no-repeat fixed;
    cursor:crosshair;
    user-select:none;
  }
  #stage{ position:fixed; inset:0; }

  /* stacked spawn images */
  .spawn{
    position:absolute; left:0; top:0;
    width:clamp(var(--spawn-min), 30vmin, var(--spawn-max)); height:auto;
    image-rendering:pixelated; pointer-events:none; /* clicks pass through for more chaos */
    transform-origin:center center; will-change:transform, left, top;
  }

  /* special popups */
  #abort{ position:absolute; width:min(44vmin, 520px); height:auto; image-rendering:pixelated; pointer-events:none; z-index:9999; }
  #angel{ position:absolute; width:min(28vmin, 360px); height:auto; image-rendering:pixelated; cursor:pointer; z-index:9980; }
</style>
</head>
<body>
  <main id="stage" aria-label="danger zone"></main>

  <!-- Background audio (tries to autoplay; will also start on first click) -->
  <audio id="bgm" src="cringevir.wav" preload="auto" autoplay playsinline></audio>

<script>
(function(){
  const stage = document.getElementById('stage');
  const bgm = document.getElementById('bgm');

  // Pool of images to cycle through on click (order repeats forever)
  const POOL = [
    'crit.png',
    'file 1.png',
    'fur1.png',
    'fur2.png',
    'fur3.png',
    'warn.png'
  ];

  let poolIndex = 0, z = 10;

  // Attempt immediate play; if blocked, unlock on first interaction
  function tryPlay(){ try{ const p = bgm.play(); if(p) p.catch(()=>{});}catch(_){} }
  document.addEventListener('DOMContentLoaded', tryPlay);
  window.addEventListener('pointerdown', ()=>{ tryPlay(); });

  // Random helpers
  const rand = (a,b)=> a + Math.random()*(b-a);
  function randPos(w,h){
    const W = window.innerWidth, H = window.innerHeight;
    return { x: Math.floor(rand(0, Math.max(0, W - w))), y: Math.floor(rand(0, Math.max(0, H - h))) };
  }

  function spawnNext(){
    const src = POOL[poolIndex]; poolIndex = (poolIndex + 1) % POOL.length;
    const img = new Image(); img.src = src; img.className = 'spawn'; img.style.zIndex = (++z).toString();

    // temp size to compute placement once loaded
    img.onload = () => {
      // scale to a random width in vmin range while respecting intrinsic ratio
      const scaleW = Math.round(rand(window.innerWidth*0.12, window.innerWidth*0.24));
      img.style.width = scaleW + 'px';
      const r = img.getBoundingClientRect();
      const p = randPos(r.width, r.height);
      img.style.left = p.x + 'px';
      img.style.top  = p.y + 'px';
      const rot = rand(-15, 15).toFixed(1);
      img.style.transform = `rotate(${rot}deg)`;
    };

    stage.appendChild(img);
  }

  // Click anywhere to spawn next image
  stage.addEventListener('pointerdown', (e)=>{ spawnNext(); });

  // ----------------------- ABORT (mouse-avoid) -----------------------
  let abortEl = null; const abortState = { x: 160, y: 120, vx: 1.2, vy: 0.9 };
  const MAX_S = 6, AVOID_R = 160, AVOID_F = 2200, FRICTION = 0.985, WANDER = 0.25;
  const mouse = { x: -9999, y: -9999 };
  window.addEventListener('pointermove', e=>{ mouse.x = e.clientX; mouse.y = e.clientY; });

  function addAbort(){
    if(abortEl) return;
    abortEl = new Image(); abortEl.id = 'abort'; abortEl.src = 'abort.png';
    stage.appendChild(abortEl);
    // center it initially
    const r = abortEl.getBoundingClientRect();
    abortState.x = (window.innerWidth - r.width)/2; abortState.y = (window.innerHeight - r.height)/2;
    abortEl.style.left = abortState.x + 'px'; abortEl.style.top = abortState.y + 'px';
  }

  function tickAbort(){
    if(!abortEl) return;
    const r = abortEl.getBoundingClientRect();
    // attraction to wander
    abortState.vx += rand(-WANDER, WANDER);
    abortState.vy += rand(-WANDER, WANDER);

    // repel from mouse if inside radius
    const cx = r.left + r.width/2, cy = r.top + r.height/2;
    const dx = cx - mouse.x, dy = cy - mouse.y;
    const d2 = dx*dx + dy*dy; const R2 = AVOID_R*AVOID_R;
    if(d2 < R2){
      const dist = Math.max(Math.sqrt(d2), 0.001);
      const f = AVOID_F / (dist*dist); // stronger when closer
      abortState.vx += (dx/dist) * f;
      abortState.vy += (dy/dist) * f;
    }

    // integrate + friction
    abortState.vx *= FRICTION; abortState.vy *= FRICTION;

    // clamp speed
    const s = Math.hypot(abortState.vx, abortState.vy);
    if(s > MAX_S){ const k = MAX_S / s; abortState.vx *= k; abortState.vy *= k; }

    // move
    abortState.x += abortState.vx; abortState.y += abortState.vy;

    // bounce off edges
    if(abortState.x <= 0){ abortState.x = 0; abortState.vx = Math.abs(abortState.vx); }
    if(abortState.y <= 0){ abortState.y = 0; abortState.vy = Math.abs(abortState.vy); }
    const maxX = window.innerWidth - r.width; const maxY = window.innerHeight - r.height;
    if(abortState.x >= maxX){ abortState.x = maxX; abortState.vx = -Math.abs(abortState.vx); }
    if(abortState.y >= maxY){ abortState.y = maxY; abortState.vy = -Math.abs(abortState.vy); }

    abortEl.style.left = abortState.x + 'px';
    abortEl.style.top  = abortState.y + 'px';
  }

  // ----------------------- ANGEL (drift, click to exit) -----------------------
  let angelEl = null; const angelState = { x: 80, y: 80, vx: 0.8, vy: 1.0 };
  const ANGEL_MAX_S = 4, ANGEL_WANDER = 0.22, ANGEL_FRICTION = 0.992;

  function addAngel(){
    if(angelEl) return;
    angelEl = new Image(); angelEl.id = 'angel'; angelEl.src = 'angel.gif';
    angelEl.addEventListener('click', ()=>{
      // try to go back; fallback to root
      try{ history.back(); }catch(_){ }
      setTimeout(()=>{ window.location.href = './'; }, 200);
    });
    stage.appendChild(angelEl);
    // place randomly near the top-right quadrant
    const r = angelEl.getBoundingClientRect();
    angelState.x = rand(window.innerWidth*0.55, Math.max(window.innerWidth - r.width - 20, window.innerWidth*0.8));
    angelState.y = rand(20, window.innerHeight*0.35);
    angelEl.style.left = angelState.x + 'px'; angelEl.style.top = angelState.y + 'px';
  }

  function tickAngel(){
    if(!angelEl) return;
    const r = angelEl.getBoundingClientRect();
    angelState.vx += rand(-ANGEL_WANDER, ANGEL_WANDER);
    angelState.vy += rand(-ANGEL_WANDER, ANGEL_WANDER);

    angelState.vx *= ANGEL_FRICTION; angelState.vy *= ANGEL_FRICTION;
    const s = Math.hypot(angelState.vx, angelState.vy);
    if(s > ANGEL_MAX_S){ const k = ANGEL_MAX_S / s; angelState.vx *= k; angelState.vy *= k; }

    angelState.x += angelState.vx; angelState.y += angelState.vy;

    // bounce
    if(angelState.x <= 0){ angelState.x = 0; angelState.vx = Math.abs(angelState.vx); }
    if(angelState.y <= 0){ angelState.y = 0; angelState.vy = Math.abs(angelState.vy); }
    const maxX = window.innerWidth - r.width; const maxY = window.innerHeight - r.height;
    if(angelState.x >= maxX){ angelState.x = maxX; angelState.vx = -Math.abs(angelState.vx); }
    if(angelState.y >= maxY){ angelState.y = maxY; angelState.vy = -Math.abs(angelState.vy); }

    angelEl.style.left = angelState.x + 'px';
    angelEl.style.top  = angelState.y + 'px';
  }

  // schedule special popups
  setTimeout(addAbort, 12000);  // 12s
  setTimeout(addAngel, 20000);  // 20s

  // main loop
  function frame(){ tickAbort(); tickAngel(); requestAnimationFrame(frame); }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
